# 08. 경계 간 매핑하기

매핑엔 항상 찬반 의견이 존재한다. 예를들면
- 매핑에 찬성 : 계층간 매핑을 하지 않으면, 양 계층에서 같은 모델을 사용해야 하는데 이러면 너무 강결합이 일어난다.
- 매핑에 반대 : 계층을 매핑하기 위한 보일러플레이트 코드가 너무 많아지고, 계층에 걸쳐 같은 모델을 사용하기 떄문에 매핑은 과하다.

### '매핑하지 않기'전략
- 매핑하지 않기 전략은 웹계층과 애플리케이션 계층이 같은 모델을 사용한다. 영속성 계층과 애플리케이션 계층도 동일하다. 모든 계층이 같은 모델을 사용하는 것이다.
- 매핑하지 않기 전략은 단일책임 원칙을 위반한다.
   - 예를들면 웹계층모델은 REST로 노출시킨 모델을 JSON 직렬화 하기위한 애너테이션이 모델의 필드에 필요할 수 있다.
   - 영속성 계층 모델은 DB 매핑을 위한 에너테이션이 필요할 수 있다.
   - 도메인과 애플리케이션 계층 모델은 웹/영속성 계층의 필드가 가지는 관심사는 관심을 갖지 않는다. 
   - 즉 어느 계층의 모델이냐에 따라 관심사가 다르고, 변경되어야 할 이유가 다르다.
- 하지만 매핑하지 않기 전략은 아예 쓸 수 없는 것은 아니다
   - 같은 필드를 가지는 웹/도메인/영속성 모델을 사용한다면 굳이 매핑할 필요 없다. 일부 거슬리는 애너테이션이 발생하면, 무시할 수도 있다.
- 그리고 매핑 전략은 항상 변경될 수 있음을 기억해야 한다.

### 양방향 매핑 전략 (Two-way)
- 계층의 모델은 도메인 모델과 다른 구조의 전용 모델을 갖는다
   - 웹 계층은 웹 모델을 인커밍 포트에 필요한 도메인 모델로 매핑한다.
   - 영속성 계층은 아웃고잉 포트가 사용하는 도메인 모델과 영속성 모델간의 매핑과 유사한 매핑을 담당한다.
- 두 계층 모두 매핑하기 때문에 양방향 매핑이라고 부른다.
- 각 계층은 전용 모델이 있기 때문에, 모델이 변경하더라도 다른 계층에는 영향이 없다. 
- 각 계층에 최적화 된 모델을 가질 수 있다.
- 이 매핑 전략은 깨끗한 도메인 모델로 이어진다. 단일책임 원칙도 만족한다.
- 이 전략은 간단하고 매핑 책임이 명확하다.
- 하지만 보일러 플레이트 코드가 많이 발생한다. 매핑의 구현 시간이 꽤 많이 든다.
- **도메인 모델이 계층 경계를 넘어 통신하는데 사용이 된다.** 인커밍포트, 아웃고잉 포트가 도메인 모델을 입력 파라미터로 사용하기 때문이다.
- 그렇기 때문에 바깥쪽 계층의 요청에 의해 변경에 취약해 질 수 있다. (바깥쪽에서 변경 때문에 나도 바뀌어야 하는 의심을 하게 된다.)
- 양방향 매핑 전략은 은탄환이 아니다. 하지만 이게 신성한 법칙처럼 여겨지곤 한다.

### 완전매핑 전략
- 각 연산마다 별도의 입출력 모델을 사용한다.
- 통신할 때 각각 입출력 포트에 도메인 모델을 사용하는것이 아니라, 작업에 특화된 모델을 사용한다.
- 모델은 보통 command, request등의 이름을 사용한다.
- 완전 매핑 전략에서는 웹 계층은 입력을 커맨드 객체로 매핑할 책임을 가진다. 각각의 핏한 모델이 생성되기에 어떤필드의 채워짐,사용안함 등을 확인할 필요는 없다.
- 애플리케이션 계층은 커맨드를 유스케이스에 따라 도메인 모델로 변경하기 위한 매핑을 책임진다.
- 이렇게 매핑하면 요구사항에 대한 모델이 많이 생성되지만, 여러 유스케이스를 한번에 다루는 모델보다 유지보수 하기에 쉽다.
- 전역 패턴으로눈 추천하지 않는다. 이 매핑전략은 웹계층/어플리케이션 계층 사이의 상태를 명확하게 할 때 가장 빛을 바란다.
- 영속성 계층과의 매핑은 오버헤드가 발생하기 때문에 사용하지 않는 것이 좋다.

### 단방향 매핑 전략
- 모든 계층의 모델들이 같은 인터페이스를 구현한다.
- 모든 계층의 모델이 구현한 인터페이스는, 관련있는 특성에 대해 getter 메서드를 제공해서 도메인 모델의 상태를 캡슐화 한다.
- 도메인 모델 자체는 풍부한 행동을 구현할 수 있고, 애플리케이션 계층 내의  서비스에서 이러한 행동에 접근할 수 있다. 도메인 객체를 바깥 게층으로 전달하고 싶으면 매핑없이 전달할 수 있다.
- 바깥 계층에서 애플리케이션 계층으로 전달하는 객체들도 이 상태 인터페이스를 구현하고 있다.
- 애플리케이션 계층에서는 이 객체를 실제 도메인 모델로 매핑해서 도메인 모델의 행동에 접근할 수 있게 된다.
- 이 매핑은 팩터리라는 DDD 개념과 잘 어울린다.
- 이 전략에서 매핑 책임은, 한 계층이 다른 계층으로 부터 객체를 받으면, 해당 계층에서 이용할 수 있도록 무언가로 매핑하는 것이다. 각 계층은 한 방향으로만 매핑한다.
- 매핑 계층을 넘나들며 퍼져 있기 때문에, 다른 전략에 비해 개념적으로 어렵다.
- 계층간 모델이 비슷할 때 효과적이다. 읽기전용 연산의 경우 인터페이스가 필요한 모든 정보를 제공하기 때문에, 웹 계층에서 전용 모델로 매핑할 필요가 없다.

### 언제 어떤 매핑 전략을 사용할 것인가
- 그떄그때 다르다...
- **전체 코드에 대한 어떤 경우에도 변하지 않는 전역 규칙으로 정의하려는 충동을 이겨내야 한다.**
- 고정된 매핑 전략을 계속 유지하기 보다, 전략을 갈아타는게 좋은 방법일 수 있다.
- 팀 내 가이드라인을 정해 놓고 유효한지 평가해야 한다.
- e.g. 변경유스케이스를 사용하고 있다면, 웹<->애플리케이션 사이는 완전매핑 전략을 첫번째로 사용한다. 애플리케이션<->영속성 계층 사이는 매핑하지 않기 전략을 선택
  지로 둔다. 하지만 애플리케이션 계층에서 영속성 문제를 다뤄야 하게 되면, '양방향' 매핑 전략으로 바꿔서 영속성 문제를 영속성 계층에 가둘 수 있게 한다.
- 쿼리 작업을 한다면, 빠르게 코드를 짜기위해 매핑하지 않기 전략이 첫번째 선택지가 되야 한다.